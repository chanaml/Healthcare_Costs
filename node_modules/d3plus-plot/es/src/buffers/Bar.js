import {max, min, sum} from "d3-array";
import {nest} from "d3-collection";

import {default as ordinalBuffer} from "./ordinalBuffer";

/**
    Adds a buffer to either side of the non-discrete axis.
    @param {Array} data
    @param {D3Scale} x
    @param {D3Scale} y
    @param {Object} [config]
    @param {Number} [buffer = 10]
    @private
*/
export default function(data, x, y, config, buffer) {
  var this$1 = this;
  if ( buffer === void 0 ) buffer = 10;


  var oppScale = this._discrete === "x" ? y : x;

  var oppDomain = oppScale.domain().slice();

  if (this._discrete === "x") { oppDomain.reverse(); }

  var negVals, posVals;
  if (this._stacked) {
    var groupedData = nest()
      .key(function (d) { return d[this$1._discrete]; })
      .entries(data)
      .map(function (d) { return d.values.map(function (x) { return x[this$1._discrete === "x" ? "y" : "x"]; }); });
    posVals = groupedData.map(function (arr) { return sum(arr.filter(function (d) { return d > 0; })); });
    negVals = groupedData.map(function (arr) { return sum(arr.filter(function (d) { return d < 0; })); });
  }
  else {
    posVals = data.map(function (d) { return d[this$1._discrete === "x" ? "y" : "x"]; });
    negVals = posVals;
  }
  var bMax = oppScale(max(posVals));
  if (bMax !== oppScale(0)) { bMax += this._discrete === "x" ? -buffer : buffer; }
  bMax = oppScale.invert(bMax);

  var bMin = oppScale(min(negVals));
  if (bMin !== oppScale(0)) { bMin += this._discrete === "x" ? buffer : -buffer; }
  bMin = oppScale.invert(bMin);

  if (bMax > oppDomain[1]) { oppDomain[1] = bMax; }
  if (bMin < oppDomain[0]) { oppDomain[0] = bMin; }

  if (this._discrete === "x") { oppDomain.reverse(); }

  oppScale.domain(oppDomain);

  var discreteScale = this._discrete === "x" ? x : y;
  discreteScale.domain(ordinalBuffer(discreteScale.domain()));

  return [x, y];

}

//# sourceMappingURL=Bar.js.map